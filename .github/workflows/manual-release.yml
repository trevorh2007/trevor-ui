name: Manual Release & NPM Publish

on:
  workflow_dispatch:
    inputs:
      release_type:
        description: "Release type"
        required: true
        default: "auto"
        type: choice
        options:
          - auto
          - patch
          - minor
          - major
      pre_release:
        description: "Mark as pre-release"
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  packages: write
  id-token: write # Required for npm provenance

env:
  NODE_VERSION: "20"

jobs:
  release:
    name: ğŸš€ Create Release
    runs-on: ubuntu-latest
    outputs:
      released: ${{ steps.create-release.outputs.released }}
      version: ${{ steps.create-release.outputs.version }}
      tag: ${{ steps.create-release.outputs.tag }}

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸŸ¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: ğŸ“¦ Install dependencies
        run: npm ci --prefer-offline --no-audit

      - name: ï¿½ Generate component registry
        run: npm run generate:registry

      - name: ï¿½ğŸ” Quality checks
        run: |
          npm run type-check
          npm run lint
          npm run test:coverage

      - name: ğŸ“Š Prepare coverage data for showcase
        run: npm run test:coverage:copy

      - name: ğŸ—ï¸ Build library
        run: npm run build:lib

      - name: ğŸ·ï¸ Determine version and create release
        id: create-release
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');

            const releaseType = '${{ github.event.inputs.release_type }}';
            const preRelease = '${{ github.event.inputs.pre_release }}' === 'true';

            console.log(`Release type: ${releaseType}`);
            console.log(`Pre-release: ${preRelease}`);

            // Get current version from last git tag (more reliable than package.json)
            let currentVersion;
            try {
              const lastTag = execSync('git describe --tags --abbrev=0 2>/dev/null', { encoding: 'utf8' }).trim();
              currentVersion = lastTag.replace(/^v/, ''); // Remove 'v' prefix
              console.log(`Current version from last tag: ${currentVersion}`);
            } catch {
              // No tags exist yet, fall back to package.json
              const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
              currentVersion = packageJson.version;
              console.log(`No tags found, using package.json version: ${currentVersion}`);
            }

            let bumpType = releaseType;
            let commits = [];

            // If auto mode, analyze commits since last release
            if (releaseType === 'auto') {
              try {
                // Try to get commits since last tag
                let commitRange;
                try {
                  const lastTag = execSync('git describe --tags --abbrev=0', { encoding: 'utf8' }).trim();
                  commitRange = `${lastTag}..HEAD`;
                } catch {
                  // No previous tags, get recent commits
                  commitRange = 'HEAD~10..HEAD';
                }
                
                const commitOutput = execSync(`git log ${commitRange} --pretty=format:"%s"`, { encoding: 'utf8' });
                commits = commitOutput.split('\n').filter(msg => msg.trim());
                
                console.log('Commits to analyze:', commits);
                
                // Analyze commit messages for semantic versioning
                bumpType = 'patch'; // default
                let hasBreaking = false;
                let hasFeature = false;
                let hasFix = false;
                
                for (const commit of commits) {
                  const msg = commit.toLowerCase();
                  
                  // Check for breaking changes
                  if (msg.includes('breaking') || msg.includes('!:') || msg.startsWith('feat!') || msg.startsWith('fix!')) {
                    hasBreaking = true;
                  }
                  // Check for features
                  else if (msg.startsWith('feat') || msg.startsWith('feature')) {
                    hasFeature = true;
                  }
                  // Check for fixes
                  else if (msg.startsWith('fix') || msg.startsWith('bugfix')) {
                    hasFix = true;
                  }
                }
                
                // Determine bump type
                if (hasBreaking) {
                  bumpType = 'major';
                } else if (hasFeature) {
                  bumpType = 'minor';
                } else if (hasFix) {
                  bumpType = 'patch';
                }
                
              } catch (error) {
                console.log('Error getting commits:', error.message);
                commits = ['Manual release triggered'];
                bumpType = 'patch';
              }
            } else {
              // Manual release type specified
              commits = [`Manual ${bumpType} release`];
            }

            console.log(`Determined bump type: ${bumpType}`);

            // Parse version
            const versionRegex = /^(\d+)\.(\d+)\.(\d+)(?:-(.+))?$/;
            const match = currentVersion.match(versionRegex);

            if (!match) {
              throw new Error(`Invalid version format: ${currentVersion}`);
            }

            let [, major, minor, patch, prerelease] = match;
            major = parseInt(major);
            minor = parseInt(minor);
            patch = parseInt(patch);

            // Calculate new version based on bump type
            let newVersion;
            if (bumpType === 'major') {
              newVersion = `${major + 1}.0.0`;
            } else if (bumpType === 'minor') {
              newVersion = `${major}.${minor + 1}.0`;
            } else {
              newVersion = `${major}.${minor}.${patch + 1}`;
            }

            // Add pre-release suffix if requested
            if (preRelease) {
              newVersion += '-alpha.1';
            }

            console.log(`Initial calculated version: ${newVersion}`);

            // Find the next available version if the calculated one already exists
            let versionExists = true;
            let attempts = 0;
            const maxAttempts = 20;

            while (versionExists && attempts < maxAttempts) {
              try {
                await github.rest.repos.getReleaseByTag({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag: `v${newVersion}`
                });
                
                console.log(`Version ${newVersion} already exists, incrementing...`);
                
                // Version exists, increment patch version
                const versionMatch = newVersion.match(/^(\d+)\.(\d+)\.(\d+)(?:-(.+))?$/);
                if (versionMatch) {
                  const [, vMajor, vMinor, vPatch, vPrerelease] = versionMatch;
                  newVersion = `${vMajor}.${vMinor}.${parseInt(vPatch) + 1}`;
                  if (vPrerelease) {
                    newVersion += `-${vPrerelease}`;
                  }
                }
                
                attempts++;
              } catch (error) {
                if (error.status === 404) {
                  // Version doesn't exist, we can use it
                  versionExists = false;
                  console.log(`Found available version: ${newVersion}`);
                } else {
                  throw error;
                }
              }
            }

            if (attempts >= maxAttempts) {
              throw new Error(`Could not find available version after ${maxAttempts} attempts`);
            }

            // Note: We don't update package.json on main anymore
            // The version bump will only happen during the NPM publish step
            console.log('Creating release without committing version bump to main');

            // Create release
            const changelog = commits.map(commit => `- ${commit}`).join('\n');

            // Use manual pre-release setting if provided, otherwise auto-detect
            const isPrerelease = preRelease || newVersion.includes('-');

            const release = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: `v${newVersion}`,
              name: `ğŸš€ Release v${newVersion}`,
              body: `## ğŸ“‹ What's Changed\n\n${changelog}\n\n**Bump Type:** ${bumpType}${isPrerelease ? '\n\nâš ï¸ **Pre-release version**' : ''}`,
              draft: false,
              prerelease: isPrerelease,
              generate_release_notes: true
            });

            console.log(`âœ… Created release: ${release.data.html_url}`);

            core.setOutput('released', 'true');
            core.setOutput('version', newVersion);
            core.setOutput('tag', `v${newVersion}`);

  publish-npm:
    name: ğŸ“¦ Publish to NPM
    runs-on: ubuntu-latest
    needs: release
    if: needs.release.outputs.released == 'true'

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.release.outputs.tag }} # Check out the release tag

      - name: ğŸŸ¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          registry-url: "https://registry.npmjs.org"

      - name: ğŸ“¦ Install dependencies
        run: npm ci --prefer-offline --no-audit

      - name: ğŸ”„ Generate component registry
        run: npm run generate:registry

      - name: ğŸ“ Update package.json version
        run: |
          echo "Updating package.json to version ${{ needs.release.outputs.version }}"
          node -e "const fs=require('fs'); const pkg=JSON.parse(fs.readFileSync('package.json')); pkg.version='${{ needs.release.outputs.version }}'; fs.writeFileSync('package.json', JSON.stringify(pkg,null,2)+'\n');"

      - name: ğŸ—ï¸ Build library
        run: npm run build:lib

      - name: ğŸ” Verify package contents
        run: |
          echo "ğŸ“‹ Package contents:"
          npm pack --dry-run
          echo ""
          echo "ğŸ“ Dist directory:"
          ls -la dist/ || echo "No dist directory found"

      - name: ğŸ“¤ Publish to NPM
        run: npm publish --access public --provenance

      - name: âœ… Publication success
        run: |
          echo "ğŸ‰ Successfully published trevor-ui@${{ needs.release.outputs.version }} to NPM!"
          echo "ğŸ“¦ View at: https://www.npmjs.com/package/trevor-ui"
